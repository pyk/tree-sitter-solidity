==================
Simple bitwise AND with hex literals
==================

uint x = 0x0F & 0xF0;

---

(source_file
  definition: (variable
    type: (primitive_type
      (uint_type))
    name: (symbol
      name: (identifier))
    value: (bitwise
      (bitand
        left: (literal
          (hex))
        operator: (bitand_op)
        right: (literal
          (hex))))))

==================
Bitwise AND with variables
==================

contract C {
    function f(bytes32 a, bytes32 b) public pure returns (bytes32) {
        return a & b;
    }
}

---

(source_file
  definition: (contract
    name: (symbol
      name: (identifier))
    definition: (function
      name: (symbol
        name: (identifier))
      parameters: (parameters
        parameter: (parameter
          type: (primitive_type
            (bytes_type))
          name: (symbol
            name: (identifier)))
        parameter: (parameter
          type: (primitive_type
            (bytes_type))
          name: (symbol
            name: (identifier))))
      visibility: (visibility)
      mutability: (pure)
      returns: (parameters
        parameter: (parameter
          type: (primitive_type
            (bytes_type))))
      body: (block
        (return_statement
          value: (bitwise
            (bitand
              left: (symbol
                name: (identifier))
              operator: (bitand_op)
              right: (symbol
                name: (identifier)))))))))

==================
Chained bitwise AND expressions (left-associative)
==================

// Should parse as (a & b) & c
uint x = a & b & c;

---

(source_file
  (comment)
  definition: (variable
    type: (primitive_type
      (uint_type))
    name: (symbol
      name: (identifier))
    value: (bitwise
      (bitand
        left: (bitwise
          (bitand
            left: (symbol
              name: (identifier))
            operator: (bitand_op)
            right: (symbol
              name: (identifier))))
        operator: (bitand_op)
        right: (symbol
          name: (identifier))))))

==================
Bitwise AND precedence with bitwise XOR and OR
==================

// Should parse as (a & b) ^ (c | d) is wrong, should be ((a&b)^c)|d
// Correct parsing should be ((a & b) ^ c) | d
uint x = a & b ^ c | d;

---

(source_file
  (comment)
  (comment)
  definition: (variable
    type: (primitive_type
      (uint_type))
    name: (symbol
      name: (identifier))
    value: (bitwise
      (bitor
        left: (bitwise
          (bitxor
            left: (bitwise
              (bitand
                left: (symbol
                  name: (identifier))
                operator: (bitand_op)
                right: (symbol
                  name: (identifier))))
            operator: (bitxor_op)
            right: (symbol
              name: (identifier))))
        operator: (bitor_op)
        right: (symbol
          name: (identifier))))))

==================
Bitwise AND precedence with shift and arithmetic operators
==================

// Should parse as (a << 1) & (b + 1)
uint x = a << 1 & b + 1;

---

(source_file
  (comment)
  definition: (variable
    type: (primitive_type
      (uint_type))
    name: (symbol
      name: (identifier))
    value: (bitwise
      (bitand
        left: (shift
          left: (symbol
            name: (identifier))
          operator: (shift_op)
          right: (literal
            (number)))
        operator: (bitand_op)
        right: (arithmetic
          (add
            left: (symbol
              name: (identifier))
            operator: (add_op)
            right: (literal
              (number))))))))

==================
Bitwise AND with parenthesized OR expression
==================

// Should parse as a & (b | c)
uint x = a & (b | c);

---

(source_file
  (comment)
  definition: (variable
    type: (primitive_type
      (uint_type))
    name: (symbol
      name: (identifier))
    value: (bitwise
      (bitand
        left: (symbol
          name: (identifier))
        operator: (bitand_op)
        right: (group
          expression: (bitwise
            (bitor
              left: (symbol
                name: (identifier))
              operator: (bitor_op)
              right: (symbol
                name: (identifier)))))))))

==================
Bitwise AND in a require statement
==================

contract C {
    uint constant FLAG = 0x01;
    function f(uint flags) public pure {
        require(flags & FLAG == FLAG, "Flag not set");
    }
}

---

(source_file
  definition: (contract
    name: (symbol
      name: (identifier))
    definition: (variable
      type: (primitive_type
        (uint_type))
      mutability: (constant)
      name: (symbol
        name: (identifier))
      value: (literal
        (hex)))
    definition: (function
      name: (symbol
        name: (identifier))
      parameters: (parameters
        parameter: (parameter
          type: (primitive_type
            (uint_type))
          name: (symbol
            name: (identifier))))
      visibility: (visibility)
      mutability: (pure)
      body: (block
        (expression_statement
          (call
            function: (builtin_function
              name: (require))
            arguments: (argument_list
              argument: (equality
                left: (bitwise
                  (bitand
                    left: (symbol
                      name: (identifier))
                    operator: (bitand_op)
                    right: (symbol
                      name: (identifier))))
                operator: (equality_op)
                right: (symbol
                  name: (identifier)))
              argument: (literal
                (string)))))))))
