==================
Simple bitwise XOR with hex literals
==================

uint x = 0xC ^ 0xA;

---

(source_file
  definition: (variable
    type: (primitive_type
      (uint_type))
    name: (symbol
      name: (identifier))
    value: (bitwise
      (bitxor
        left: (literal
          (hex))
        operator: (bitxor_op)
        right: (literal
          (hex))))))

==================
Bitwise XOR with variables
==================

contract C {
    function f(uint a, uint b) public pure returns (uint) {
        return a ^ b;
    }
}

---

(source_file
  definition: (contract
    name: (symbol
      name: (identifier))
    definition: (function
      name: (symbol
        name: (identifier))
      parameters: (parameters
        parameter: (parameter
          type: (primitive_type
            (uint_type))
          name: (symbol
            name: (identifier)))
        parameter: (parameter
          type: (primitive_type
            (uint_type))
          name: (symbol
            name: (identifier))))
      visibility: (visibility)
      mutability: (state_mutability)
      returns: (parameters
        parameter: (parameter
          type: (primitive_type
            (uint_type))))
      body: (block
        (return_statement
          value: (bitwise
            (bitxor
              left: (symbol
                name: (identifier))
              operator: (bitxor_op)
              right: (symbol
                name: (identifier)))))))))

==================
Chained bitwise XOR expressions (left-associative)
==================

// Should parse as (a ^ b) ^ c
uint x = a ^ b ^ c;

---

(source_file
  (comment)
  definition: (variable
    type: (primitive_type
      (uint_type))
    name: (symbol
      name: (identifier))
    value: (bitwise
      (bitxor
        left: (bitwise
          (bitxor
            left: (symbol
              name: (identifier))
            operator: (bitxor_op)
            right: (symbol
              name: (identifier))))
        operator: (bitxor_op)
        right: (symbol
          name: (identifier))))))

==================
Bitwise XOR precedence with bitwise AND (critical test)
==================

// Should parse as a ^ (b & c) because AND is higher precedence
uint x = a ^ b & c;

---

(source_file
  (comment)
  definition: (variable
    type: (primitive_type
      (uint_type))
    name: (symbol
      name: (identifier))
    value: (bitwise
      (bitxor
        left: (symbol
          name: (identifier))
        operator: (bitxor_op)
        right: (bitwise
          (bitand
            left: (symbol
              name: (identifier))
            operator: (bitand_op)
            right: (symbol
              name: (identifier))))))))

==================
Bitwise XOR precedence with bitwise OR (critical test)
==================

// Should parse as (a ^ b) | c because OR is lower precedence
uint x = a ^ b | c;

---

(source_file
  (comment)
  definition: (variable
    type: (primitive_type
      (uint_type))
    name: (symbol
      name: (identifier))
    value: (bitwise
      (bitor
        left: (bitwise
          (bitxor
            left: (symbol
              name: (identifier))
            operator: (bitxor_op)
            right: (symbol
              name: (identifier))))
        operator: (bitor_op)
        right: (symbol
          name: (identifier))))))

==================
Bitwise XOR precedence with comparison operators
==================

// Should parse as (a ^ b) > c
bool x = a ^ b > c;

---

(source_file
  (comment)
  definition: (variable
    type: (primitive_type
      (bool_type))
    name: (symbol
      name: (identifier))
    value: (comparison
      left: (bitwise
        (bitxor
          left: (symbol
            name: (identifier))
          operator: (bitxor_op)
          right: (symbol
            name: (identifier))))
      operator: (comparison_op)
      right: (symbol
        name: (identifier)))))

==================
Bitwise XOR with parenthesized expression
==================

// Should parse as a ^ (b + c)
uint x = a ^ (b + c);

---

(source_file
  (comment)
  definition: (variable
    type: (primitive_type
      (uint_type))
    name: (symbol
      name: (identifier))
    value: (bitwise
      (bitxor
        left: (symbol
          name: (identifier))
        operator: (bitxor_op)
        right: (group
          expression: (arithmetic
            (add
              left: (symbol
                name: (identifier))
              operator: (add_op)
              right: (symbol
                name: (identifier)))))))))

==================
Bitwise XOR in an assignment expression
==================

contract C {
    function f(uint a, uint b) public {
        a ^= b;
    }
}

---

(source_file
  definition: (contract
    name: (symbol
      name: (identifier))
    definition: (function
      name: (symbol
        name: (identifier))
      parameters: (parameters
        parameter: (parameter
          type: (primitive_type
            (uint_type))
          name: (symbol
            name: (identifier)))
        parameter: (parameter
          type: (primitive_type
            (uint_type))
          name: (symbol
            name: (identifier))))
      visibility: (visibility)
      body: (block
        (expression_statement
          (assignment_expression
            left: (symbol
              name: (identifier))
            operator: (compound_assignment_operator)
            right: (symbol
              name: (identifier))))))))
