==================
Address as a state variable
==================

contract C {
  address owner;
  address payable recipient;
}

---

(source_file
  definition: (contract
    name: (symbol
      name: (identifier))
    definition: (variable
      type: (primitive_type
        (address_type))
      name: (symbol
        name: (identifier)))
    definition: (variable
      type: (primitive_type
        (address_type))
      name: (symbol
        name: (identifier)))))

==================
Address as a function parameter and return type
==================

contract C {
  function process(address sender, address payable receiver) public pure returns (address payable) {
    return receiver;
  }
}

---

(source_file
  definition: (contract
    name: (symbol
      name: (identifier))
    definition: (function
      name: (symbol
        name: (identifier))
      parameters: (parameters
        parameter: (parameter
          type: (primitive_type
            (address_type))
          name: (symbol
            name: (identifier)))
        parameter: (parameter
          type: (primitive_type
            (address_type))
          name: (symbol
            name: (identifier))))
      visibility: (public)
      mutability: (pure)
      returns: (parameters
        parameter: (parameter
          type: (primitive_type
            (address_type))))
      body: (block
        (return_statement
          value: (symbol
            name: (identifier)))))))

==================
Address as a local variable
==================

contract C {
  function f() public view {
    address localAddress = msg.sender;
  }
}

---

(source_file
  definition: (contract
    name: (symbol
      name: (identifier))
    definition: (function
      name: (symbol
        name: (identifier))
      visibility: (public)
      mutability: (view)
      body: (block
        (variable_declaration_statement
          declaration: (variable_declaration
            type: (primitive_type
              (address_type))
            name: (symbol
              name: (identifier)))
          value: (symbol
            scope: (symbol
              name: (identifier))
            name: (identifier)))))))

==================
Address in a type cast
==================

contract C {
  function f(bytes20 b) public pure returns (address) {
    return address(b);
  }
}

---

(source_file
  definition: (contract
    name: (symbol
      name: (identifier))
    definition: (function
      name: (symbol
        name: (identifier))
      parameters: (parameters
        parameter: (parameter
          type: (primitive_type
            (bytes_type))
          name: (symbol
            name: (identifier))))
      visibility: (public)
      mutability: (pure)
      returns: (parameters
        parameter: (parameter
          type: (primitive_type
            (address_type))))
      body: (block
        (return_statement
          value: (cast
            type: (primitive_type
              (address_type))
            argument: (symbol
              name: (identifier))))))))

==================
Payable conversion expression
==================

contract C {
  function f(address addr) public pure returns (address payable) {
    return payable(addr);
  }
}

---

(source_file
  definition: (contract
    name: (symbol
      name: (identifier))
    definition: (function
      name: (symbol
        name: (identifier))
      parameters: (parameters
        parameter: (parameter
          type: (primitive_type
            (address_type))
          name: (symbol
            name: (identifier))))
      visibility: (public)
      mutability: (pure)
      returns: (parameters
        parameter: (parameter
          type: (primitive_type
            (address_type))))
      body: (block
        (return_statement
          value: (payable_conversion_expression
            arguments: (arguments
              argument: (symbol
                name: (identifier)))))))))

==================
Address in a struct definition
==================

contract C {
  struct User {
    address addr;
    address payable withdrawalAddress;
  }
}

---

(source_file
  definition: (contract
    name: (symbol
      name: (identifier))
    definition: (struct
      name: (symbol
        name: (identifier))
      member: (struct_member
        type: (primitive_type
          (address_type))
        name: (symbol
          name: (identifier)))
      member: (struct_member
        type: (primitive_type
          (address_type))
        name: (symbol
          name: (identifier))))))

==================
Address as a mapping key and value
==================

contract C {
  mapping(address => address payable) public delegates;
}

---

(source_file
  definition: (contract
    name: (symbol
      name: (identifier))
    definition: (variable
      type: (mapping_type
        key: (primitive_type
          (address_type))
        value: (primitive_type
          (address_type)))
      visibility: (public)
      name: (symbol
        name: (identifier)))))

==================
Address as an array base type
==================

contract C {
  address[] public users;
  address payable[5] public payees;
}

---

(source_file
  definition: (contract
    name: (symbol
      name: (identifier))
    definition: (variable
      type: (array_type
        base: (primitive_type
          (address_type)))
      visibility: (public)
      name: (symbol
        name: (identifier)))
    definition: (variable
      type: (array_type
        base: (primitive_type
          (address_type))
        size: (literal
          (number)))
      visibility: (public)
      name: (symbol
        name: (identifier)))))

==================
Address in a 'using for' directive
==================

library AddressUtils {}
using AddressUtils for address;
using AddressUtils for address payable;

---

(source_file
  definition: (library
    name: (symbol
      name: (identifier)))
  directive: (using
    (using_library
      library: (symbol
        name: (identifier))
      target: (primitive_type
        (address_type))))
  directive: (using
    (using_library
      library: (symbol
        name: (identifier))
      target: (primitive_type
        (address_type)))))

==================
Address as a constant variable
==================

contract C {
  address constant ZERO_ADDRESS = address(0);
}

---

(source_file
  definition: (contract
    name: (symbol
      name: (identifier))
    definition: (variable
      type: (primitive_type
        (address_type))
      mutability: (constant)
      name: (symbol
        name: (identifier))
      value: (cast
        type: (primitive_type
          (address_type))
        argument: (literal
          (number))))))

==================
Address in an event parameter
==================

contract C {
  event Transfer(address indexed from, address indexed to);
}

---

(source_file
  definition: (contract
    name: (symbol
      name: (identifier))
    definition: (event
      name: (symbol
        name: (identifier))
      parameters: (event_parameters
        parameter: (event_parameter
          type: (primitive_type
            (address_type))
          indexed: (indexed)
          name: (symbol
            name: (identifier)))
        parameter: (event_parameter
          type: (primitive_type
            (address_type))
          indexed: (indexed)
          name: (symbol
            name: (identifier)))))))

==================
Address in an error parameter
==================

contract C {
  error InvalidSender(address sender);
}

---

(source_file
  definition: (contract
    name: (symbol
      name: (identifier))
    definition: (error
      name: (symbol
        name: (identifier))
      parameters: (error_parameters
        parameter: (error_parameter
          type: (primitive_type
            (address_type))
          name: (symbol
            name: (identifier)))))))

==================
Address as underlying type for UDVT
==================

type Wallet is address;

---

(source_file
  definition: (type
    name: (symbol
      name: (identifier))
    base: (primitive_type
      (address_type))))
